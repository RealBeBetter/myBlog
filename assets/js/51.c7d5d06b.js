(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{645:function(_,v,e){"use strict";e.r(v);var a=e(11),t=Object(a.a)({},(function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("h2",{attrs:{id:"一、简介"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一、简介"}},[_._v("#")]),_._v(" 一、简介")]),_._v(" "),e("p",[e("code",[_._v("HashMap")]),_._v("是基于"),e("code",[_._v("Map")]),_._v("接口的具体实现类，可以存储"),e("code",[_._v("null")]),_._v("键和"),e("code",[_._v("null")]),_._v("值。")]),_._v(" "),e("p",[_._v("相比于"),e("code",[_._v("Hashtable")]),_._v("，"),e("code",[_._v("HashMap")]),_._v("是线程不安全的，没有同步操作，效率高。")]),_._v(" "),e("h2",{attrs:{id:"二、键唯一性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二、键唯一性"}},[_._v("#")]),_._v(" 二、键唯一性")]),_._v(" "),e("p",[e("code",[_._v("HashMap")]),_._v("中的泛型是"),e("code",[_._v("<K,V>")]),_._v("格式的，在具体的实现中，HashMap是可以保证键的唯一性的，但是存在特殊情况。")]),_._v(" "),e("ul",[e("li",[e("p",[_._v("如果是基本数据类型或者内置数据类型的包装类，例如："),e("code",[_._v("Integer")]),_._v("、"),e("code",[_._v("String")]),_._v("等，可以保证键的唯一性。如果添加相同的键的数据多次，则会按照添加顺序覆盖最先添加的数据。")])]),_._v(" "),e("li",[e("p",[_._v("如果是引用数据，如"),e("code",[_._v("Object")]),_._v("类，则不能保证键的唯一性，即不能保证去重效果。想要保证去重效果，则需要在定义类的时候重写"),e("code",[_._v("hashCode()")]),_._v("方法和"),e("code",[_._v("equals()")]),_._v("方法")]),_._v(" "),e("p",[e("img",{attrs:{src:"https://s2.loli.net/2022/04/29/L6eGZIvjD4b38Jp.png",alt:"image-20220429213515625"}})])])]),_._v(" "),e("h2",{attrs:{id:"三、结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三、结构"}},[_._v("#")]),_._v(" 三、结构")]),_._v(" "),e("p",[_._v("在jdk 8中，HashMap是由"),e("strong",[_._v("数组+链表+红黑树")]),_._v("共同实现的。")]),_._v(" "),e("p",[e("img",{attrs:{src:"https://s2.loli.net/2022/04/01/EMzec6YWyvrhp2o.png",alt:"image-20220401103313165"}})]),_._v(" "),e("h2",{attrs:{id:"四、扩容"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#四、扩容"}},[_._v("#")]),_._v(" 四、扩容")]),_._v(" "),e("ul",[e("li",[_._v("扩容长度：默认数组的长度是16，并且发生扩容的时候，长度都为之前的"),e("code",[_._v("2倍")]),_._v("。也就是说，长度只可能为16、32、64……")]),_._v(" "),e("li",[_._v("加载因子：扩容发生的阈值，因为扩容是在容量用完之前就需要进行的。如果等到用完之后需要添加大量数据，这个时候还没来得及扩容就会发生容量不够用的情况。\n"),e("ul",[e("li",[_._v("目前的阈值参数为0.75。如果按照初始值容量计算，当占用容量空间达到"),e("code",[_._v("16*0.75=12")]),_._v("时，就会发生扩容，扩容之后的容量变为"),e("code",[_._v("16*2=32")]),_._v("；后续情况依此类推。")])])]),_._v(" "),e("li",[_._v("转换为红黑树：当哈希表上同一位置上的数据过多，即单一"),e("code",[_._v("Node")]),_._v("上的数据量过多，该"),e("code",[_._v("Node")]),_._v("上的数据默认会使用链表的结构进行排列，数据过多就会造成效率低下，JDK 8中对此情况做了优化：数据量到一定程度的时候，将链表形式的数据转换为红黑树的结构。\n"),e("ul",[e("li",[_._v("转换条件：如果一条链表中元素的个数达到"),e("code",[_._v("TREEIFY_THRESHOLD")]),_._v("（默认是8），并且table的长度大于 "),e("code",[_._v("MIN_TREEIFY_CAPACITY")]),_._v("（默认是64），就会将链表转为红黑树来提高效率（JDK 8）。")]),_._v(" "),e("li",[_._v("如果一条链表中元素的个数达到"),e("code",[_._v("TREEIFY_THRESHOLD")]),_._v("（默认是8），并且table的长度小于 "),e("code",[_._v("MIN_TREEIFY_CAPACITY")]),_._v("（默认是64），那么链表并不会转为红黑树，而是将数组扩大至原来的2倍（并且是每添加一 次就扩大2倍），直到数组长度达到64（此时链表就可以转为红黑树了），也就达到了效率最高。\n"),e("ul",[e("li",[_._v("前者满足，后者不满足：则链表中每添加一个数据，数组长度扩大为原来的两倍，直至table的长度达到 "),e("code",[_._v("MIN_TREEIFY_CAPACITY")]),_._v("（默认是64），转换为红黑树。")]),_._v(" "),e("li",[_._v("前者不满足，后者满足：链表中数据长度不足够转换为红黑树，两者效率差距不大，直至链表中数据增加至"),e("code",[_._v("TREEIFY_THRESHOLD")]),_._v("（默认是8），转换为红黑树。")])])])])])]),_._v(" "),e("h2",{attrs:{id:"五、treemap"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#五、treemap"}},[_._v("#")]),_._v(" 五、TreeMap")]),_._v(" "),e("p",[e("code",[_._v("TreeMap")]),_._v("是基于红黑树（Red-Black tree）的 "),e("code",[_._v("NavigableMap")]),_._v(" 的实现类。")]),_._v(" "),e("p",[_._v("该映射根据其键的自然顺序进行排序， 或者根据创建映射时提供的 "),e("code",[_._v("Comparator")]),_._v(" 进行排序，具体取决于使用的构造方法。")]),_._v(" "),e("p",[_._v("实现类中不包含同步代码块，线程非安全，效率高。")])])}),[],!1,null,null,null);v.default=t.exports}}]);